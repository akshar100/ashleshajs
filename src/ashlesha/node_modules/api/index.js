var YUI = require('yui'),
    email = require('nodemailer'),
    Y, api = {},
    crypto = require('crypto'),
    cradle = require("cradle");

var c = new(cradle.Connection)("http://@COUCHHOST@", 5984, {
    cache: true,
    raw: false
});
var db = c.database('@COUCHDB_NAME@');

exports.setYInstance = function(c) {
    Y = c;
};

var hash = function(pwd, salt) {
    var shasum = crypto.createHash('sha1');
    shasum.update(pwd + salt);
    return shasum.digest('hex');
};

function login(config, callback) {
    var username = config.username,
        password = config.password,
        user;
    db.view('user/byEmail', {
        key: username
    }, function(err, docs) {
        if (docs && docs.length > 0) {
            user = docs.pop();

            if (user.value.password === api.user.hash_password({
                val: password
            })) {
                if (Y.Lang.isFunction(callback)) {
                    callback(null, {
                        success: true,
                        user: user.value
                    });
                    Y.fire("UpdateUser", {
                        user: user.value,
                        success: true
                    });
                }
            }
            else {
                if (Y.Lang.isFunction(callback)) {
                    callback(null, {
                        success: false
                    });
                }
                Y.fire("UpdateUser", {
                    success: false,
                    user: null
                });

            }
        }
        else {
            if (Y.Lang.isFunction(callback)) {
                callback(null, {
                    success: false
                });
            }
            Y.fire("UpdateUser", {
                success: false,
                user: null
            });
        }
    });

}
api.user = {
    is_taken: function(config) {
        return {
            taken: false
        };
    },
    hash_password: function(config) {
        var salt = "@PASSWORD_SALT@";
        return hash(config.val, salt);
    },
    getFriends: function(config,callback){
    	
    	var user_id = config.user_id, query = config.query || null;
    	if(user_id)
    	{
    		if(!query){
    			
    			api.relations.getByRelation({user_id:user_id,relation:'friend'},callback);
    		}
    		
    	}
    	else
    	{
    		callback({
    			error:"No user provided"
    		});
    	}
    }
};

api.list = {
    "PostList": function(config, callback) {
        var tType = (config.query && config.query.tType) || "";

        if (tType === "fanpages") {
            db.view("posts/getFanpagePosts", {
                limit: 10,
                descending: true,
                key: config.query.pageID
            }, function(err, res) {
                var list = [];
                res.forEach(function(row) {
                    row.id = row._id;
                    list.push(row);
                });
                callback(null, list);
                return;
            });
        }
        else if (tType === "wardrobe-entry") {
            db.view("posts/getWardrobeEntries", {
                limit: 10,
                descending: true,
                key: config.query.owner_id
            }, function(err, res) {
                var list = [];
                res.forEach(function(row) {
                    row.id = row._id;
                    list.push(row);
                });
                callback(null, list);
                return;
            });
        }
        else {
            db.view('posts/getPosts', {
                limit: 10,
                descending: true
            }, function(err, res) {
                var list = [];
                res.forEach(function(row) {
                    row.id = row._id;
                    list.push(row);
                });
                callback(null, list);
                return;
            });
        }

    },
    "FanPageList": function(config, callback) {
        db.view("pages/fanpages", {
            limit: 10,
            descending: true
        }, function(err, res) {
            var list = [];
            res.forEach(function(row) {
                row.id = row._id;
                list.push(row);
            });
            callback(null, list);
        });
    }
};

api.db = {
    update: function(config, callback) {
        var db, c;
        try {

            c = new(cradle.Connection)("http://@COUCHHOST@", 5984, {
                cache: true,
                raw: false
            });
            db = c.database('@COUCHDB_NAME@');


            db.save('_design/user', {
                views: {
                    byEmail: {
                        map: 'function(doc){ if(doc.email){ emit(doc.email,doc); }}'
                    },
                    asProtected: {
                    	map:'function(doc){ delete doc.password; delete doc.create_at; delete doc.update_at; doc.email; emit(doc._id,doc);}' 
                    }
                }
            }, function(err, data) {


            });
            db.save('_design/posts', {
                views: {
                    getPosts: {
                        map: 'function(doc){ if(doc.type=="PostModel" && (!doc.tType || doc.tType=="publishing-page")){ emit(doc.created_at,doc); }}'
                    },
                    getFanpagePosts: {
                        map: 'function(doc){ if(doc.type==="PostModel" && doc.tType && doc.tType==="fanpages"){ emit(doc.owner_id,doc); } }'
                    },
                    getWardrobeEntries: {
                        map: 'function(doc){ if(doc.type==="PostModel" && doc.tType && doc.tType==="wardrobe-entry"){ emit(doc.author_id,doc); } }'
                    }
                }
            }, function(err, data) {


            });

            db.save('_design/relations', {
                views: {
                    getRelation: {
                        map: 'function(doc){ if(doc.type==="relation"){ emit([doc.source,doc.target],doc.relation); }}'
                    },
                    getRelatedOf: {
                    	map: 'function(doc){ if(doc.type==="relation"){ emit([doc.source,doc.relation])   }}' 
                    }
                }
            }, function(err, data) {


            });


            db.save('_design/pages', {
                views: {
                    fanpages: {
                        map: 'function(doc){ if(doc.type=="FanPageModel"){ emit(doc.created_at,doc); }}'
                    }
                }
            }, function(err, data) {


            });
        } catch (ex) {
            Y.log("Exception in DB update" + ex);
        }

    }
};

api.relations = {
    "getRelation": function(config, callback) {
        var doc = config.source+"_relations",response=[];
        db.get(doc,function(err,doc){
        	var relations = doc && doc[config.target];
        	if(!err){
        		if(relations){
        			Y.Object.each(relations,function(item,key){
        				if(item)
        				{
        					response.push(key);
        				}
        			});
        		}
        	}
        	callback(null,response);
        });
    },
    "createRelation": function(config,callback){
    	var docName = config.source+"_relations"; //userid_relations
    	
    	db.get(docName, function (err, doc) {
    		var data = {
    			type:"relations",
    			
    		};
    	  data[config.target] = {};
    	  data[config.target][config.relation] = true;
	      if(err){//means the relationship does not exist
	      	db.save(docName,data);
	      }
	      else{
	      	if(!doc[config.target])
	      	{
	      		doc[config.target] = {};
	      	}
	      	doc[config.target][config.relation] = true;
	      	db.save(docName,doc);
	      }
	      if(config.twoway){
	      	Y.api.invoke("/relations/createRelation",{
	      		source:config.target,
	      		target:config.source,
	      		relation:config.relation
	      	},function(){});
	      }
	      if(config.reverseRelation){
	      	Y.api.invoke("/relations/createRelation",{
	      		source:config.target,
	      		target:config.source,
	      		relation:config.reverseRelation
	      	},function(){});
	      }
	      callback(null,[]);
	      
	  });
    },
    "deleteRelation": function(config,callback){
    	var docName = config.source+"_relations"; //userid_relations
    	
    	db.get(docName, function (err, doc) {
    		var data = {
    			type:"relations",
    			
    		};
    	  data[config.target] = {};
    	  data[config.target][config.relation] = false;
	      if(err){//means the relationship does not exist
	      	db.save(docName,data);
	      }
	      else{
	      	if(!doc[config.target])
	      	{
	      		doc[config.target] = {};
	      	}
	      	doc[config.target][config.relation] = false;
	      	db.save(docName,doc);
	      }
	      if(config.twoway){
	      	Y.api.invoke("/relations/deleteRelation",{
	      		source:config.target,
	      		target:config.source,
	      		relation:config.relation
	      	});
	      }
	      if(config.reverseRelation){
	      	Y.api.invoke("/relations/deleteRelation",{
	      		source:config.target,
	      		target:config.source,
	      		relation:config.reverseRelation
	      	},function(){});
	      }
	      callback(null,[]);
	      
	  });
    },
    "getByRelation":function(config,callback){
    	var docName = config.user_id+"_relations",response = [],output=[]; //userid_relations
    	db.get(docName, function (err, doc) {
    		if(err){
    			callback(null,[]);
    		}
    		else
    		{
    			Y.Object.each(doc,function(item,key){
    				if(Y.Lang.isObject(item)){
    					if(item && item[config.relation]){
    						response.push(key);
    					}
    				}
    			});
    			response.forEach(function(item){
    				
    				db.get(item,function(err,doc){
    					output.push(doc);
    					
    				});
    			});
    			callback(null,output);
    		}
    	});
    }
};

exports.api = function(path, config, callback) {
    var out, pathTokens;
    switch (path) {

    case "/login":
        out = login(config, callback);
        return out;
    default:
        pathTokens = path.split("/");
        if (pathTokens.length > 0) {
            api[pathTokens[1]][pathTokens[2]](config, callback); //0th one is empty string
        }           
    }

}








var smtpTransport = email.createTransport("SMTP", {
    service: "Gmail",
    auth: {
        user: "akshar@akshar.co.in",
        pass: "inbullsx10.1"
    }
});

var mailOptions = {
    from: "Akshar Prabhu Desai <akshar@e-yantra.org>",
    // sender address
    to: "akshar@akskah.co.in",
    // list of receivers
    subject: "Hello ",
    // Subject line
    text: "Hello world ",
    // plaintext body
    html: "<b>Hello world </b>" // html body
}

function send_email() {
    smtpTransport.sendMail(mailOptions, function(error, response) {
        if (error) {
            console.log(error);
        } else {
            console.log("Message sent: " + response.message);
        }

        // if you don't want to use this transport object anymore, uncomment following line
        smtpTransport.close(); // shut down the connection pool, no more messages
    });
}